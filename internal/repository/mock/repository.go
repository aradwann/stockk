// Code generated by MockGen. DO NOT EDIT.
// Source: stockk/internal/repository (interfaces: IngredientRepository,OrderRepository,ProductRepository,TaskQueueRepository,Transaction)
//
// Generated by this command:
//
//	mockgen -package mockrepository -destination internal/repository/mock/repository.go stockk/internal/repository IngredientRepository,OrderRepository,ProductRepository,TaskQueueRepository,Transaction
//

// Package mockrepository is a generated GoMock package.
package mockrepository

import (
	context "context"
	sql "database/sql"
	reflect "reflect"
	models "stockk/internal/models"
	repository "stockk/internal/repository"

	asynq "github.com/hibiken/asynq"
	gomock "go.uber.org/mock/gomock"
)

// MockIngredientRepository is a mock of IngredientRepository interface.
type MockIngredientRepository struct {
	ctrl     *gomock.Controller
	recorder *MockIngredientRepositoryMockRecorder
	isgomock struct{}
}

// MockIngredientRepositoryMockRecorder is the mock recorder for MockIngredientRepository.
type MockIngredientRepositoryMockRecorder struct {
	mock *MockIngredientRepository
}

// NewMockIngredientRepository creates a new mock instance.
func NewMockIngredientRepository(ctrl *gomock.Controller) *MockIngredientRepository {
	mock := &MockIngredientRepository{ctrl: ctrl}
	mock.recorder = &MockIngredientRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIngredientRepository) EXPECT() *MockIngredientRepositoryMockRecorder {
	return m.recorder
}

// CheckLowStockIngredients mocks base method.
func (m *MockIngredientRepository) CheckLowStockIngredients(ctx context.Context) ([]models.Ingredient, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckLowStockIngredients", ctx)
	ret0, _ := ret[0].([]models.Ingredient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckLowStockIngredients indicates an expected call of CheckLowStockIngredients.
func (mr *MockIngredientRepositoryMockRecorder) CheckLowStockIngredients(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckLowStockIngredients", reflect.TypeOf((*MockIngredientRepository)(nil).CheckLowStockIngredients), ctx)
}

// GetIngredientByID mocks base method.
func (m *MockIngredientRepository) GetIngredientByID(ctx context.Context, tx repository.Transaction, ingredientID int) (*models.Ingredient, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetIngredientByID", ctx, tx, ingredientID)
	ret0, _ := ret[0].(*models.Ingredient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetIngredientByID indicates an expected call of GetIngredientByID.
func (mr *MockIngredientRepositoryMockRecorder) GetIngredientByID(ctx, tx, ingredientID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIngredientByID", reflect.TypeOf((*MockIngredientRepository)(nil).GetIngredientByID), ctx, tx, ingredientID)
}

// MarkAlertSent mocks base method.
func (m *MockIngredientRepository) MarkAlertSent(ctx context.Context, ingredientID int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkAlertSent", ctx, ingredientID)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkAlertSent indicates an expected call of MarkAlertSent.
func (mr *MockIngredientRepositoryMockRecorder) MarkAlertSent(ctx, ingredientID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkAlertSent", reflect.TypeOf((*MockIngredientRepository)(nil).MarkAlertSent), ctx, ingredientID)
}

// UpdateStock mocks base method.
func (m *MockIngredientRepository) UpdateStock(ctx context.Context, tx repository.Transaction, ingredientID int, newStock float64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateStock", ctx, tx, ingredientID, newStock)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateStock indicates an expected call of UpdateStock.
func (mr *MockIngredientRepositoryMockRecorder) UpdateStock(ctx, tx, ingredientID, newStock any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateStock", reflect.TypeOf((*MockIngredientRepository)(nil).UpdateStock), ctx, tx, ingredientID, newStock)
}

// MockOrderRepository is a mock of OrderRepository interface.
type MockOrderRepository struct {
	ctrl     *gomock.Controller
	recorder *MockOrderRepositoryMockRecorder
	isgomock struct{}
}

// MockOrderRepositoryMockRecorder is the mock recorder for MockOrderRepository.
type MockOrderRepositoryMockRecorder struct {
	mock *MockOrderRepository
}

// NewMockOrderRepository creates a new mock instance.
func NewMockOrderRepository(ctrl *gomock.Controller) *MockOrderRepository {
	mock := &MockOrderRepository{ctrl: ctrl}
	mock.recorder = &MockOrderRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOrderRepository) EXPECT() *MockOrderRepositoryMockRecorder {
	return m.recorder
}

// BeginTransaction mocks base method.
func (m *MockOrderRepository) BeginTransaction() (repository.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTransaction")
	ret0, _ := ret[0].(repository.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginTransaction indicates an expected call of BeginTransaction.
func (mr *MockOrderRepositoryMockRecorder) BeginTransaction() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTransaction", reflect.TypeOf((*MockOrderRepository)(nil).BeginTransaction))
}

// CreateOrder mocks base method.
func (m *MockOrderRepository) CreateOrder(ctx context.Context, tx repository.Transaction, order *models.Order) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateOrder", ctx, tx, order)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateOrder indicates an expected call of CreateOrder.
func (mr *MockOrderRepositoryMockRecorder) CreateOrder(ctx, tx, order any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrder", reflect.TypeOf((*MockOrderRepository)(nil).CreateOrder), ctx, tx, order)
}

// CreateOrderOptimized mocks base method.
func (m *MockOrderRepository) CreateOrderOptimized(ctx context.Context, orderItems []models.OrderItem) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateOrderOptimized", ctx, orderItems)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateOrderOptimized indicates an expected call of CreateOrderOptimized.
func (mr *MockOrderRepositoryMockRecorder) CreateOrderOptimized(ctx, orderItems any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrderOptimized", reflect.TypeOf((*MockOrderRepository)(nil).CreateOrderOptimized), ctx, orderItems)
}

// GetOrderByID mocks base method.
func (m *MockOrderRepository) GetOrderByID(ctx context.Context, orderId int) (*models.Order, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrderByID", ctx, orderId)
	ret0, _ := ret[0].(*models.Order)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOrderByID indicates an expected call of GetOrderByID.
func (mr *MockOrderRepositoryMockRecorder) GetOrderByID(ctx, orderId any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrderByID", reflect.TypeOf((*MockOrderRepository)(nil).GetOrderByID), ctx, orderId)
}

// MockProductRepository is a mock of ProductRepository interface.
type MockProductRepository struct {
	ctrl     *gomock.Controller
	recorder *MockProductRepositoryMockRecorder
	isgomock struct{}
}

// MockProductRepositoryMockRecorder is the mock recorder for MockProductRepository.
type MockProductRepositoryMockRecorder struct {
	mock *MockProductRepository
}

// NewMockProductRepository creates a new mock instance.
func NewMockProductRepository(ctrl *gomock.Controller) *MockProductRepository {
	mock := &MockProductRepository{ctrl: ctrl}
	mock.recorder = &MockProductRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProductRepository) EXPECT() *MockProductRepositoryMockRecorder {
	return m.recorder
}

// GetProductById mocks base method.
func (m *MockProductRepository) GetProductById(ctx context.Context, tx repository.Transaction, productId int) (*models.Product, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetProductById", ctx, tx, productId)
	ret0, _ := ret[0].(*models.Product)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetProductById indicates an expected call of GetProductById.
func (mr *MockProductRepositoryMockRecorder) GetProductById(ctx, tx, productId any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProductById", reflect.TypeOf((*MockProductRepository)(nil).GetProductById), ctx, tx, productId)
}

// MockTaskQueueRepository is a mock of TaskQueueRepository interface.
type MockTaskQueueRepository struct {
	ctrl     *gomock.Controller
	recorder *MockTaskQueueRepositoryMockRecorder
	isgomock struct{}
}

// MockTaskQueueRepositoryMockRecorder is the mock recorder for MockTaskQueueRepository.
type MockTaskQueueRepositoryMockRecorder struct {
	mock *MockTaskQueueRepository
}

// NewMockTaskQueueRepository creates a new mock instance.
func NewMockTaskQueueRepository(ctrl *gomock.Controller) *MockTaskQueueRepository {
	mock := &MockTaskQueueRepository{ctrl: ctrl}
	mock.recorder = &MockTaskQueueRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTaskQueueRepository) EXPECT() *MockTaskQueueRepositoryMockRecorder {
	return m.recorder
}

// EnqueueAlertEmailTask mocks base method.
func (m *MockTaskQueueRepository) EnqueueAlertEmailTask(ctx context.Context, payload *repository.PayloadSendAlertEmail, opts ...asynq.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, payload}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "EnqueueAlertEmailTask", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// EnqueueAlertEmailTask indicates an expected call of EnqueueAlertEmailTask.
func (mr *MockTaskQueueRepositoryMockRecorder) EnqueueAlertEmailTask(ctx, payload any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, payload}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnqueueAlertEmailTask", reflect.TypeOf((*MockTaskQueueRepository)(nil).EnqueueAlertEmailTask), varargs...)
}

// MockTransaction is a mock of Transaction interface.
type MockTransaction struct {
	ctrl     *gomock.Controller
	recorder *MockTransactionMockRecorder
	isgomock struct{}
}

// MockTransactionMockRecorder is the mock recorder for MockTransaction.
type MockTransactionMockRecorder struct {
	mock *MockTransaction
}

// NewMockTransaction creates a new mock instance.
func NewMockTransaction(ctrl *gomock.Controller) *MockTransaction {
	mock := &MockTransaction{ctrl: ctrl}
	mock.recorder = &MockTransactionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransaction) EXPECT() *MockTransactionMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MockTransaction) Commit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockTransactionMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockTransaction)(nil).Commit))
}

// Exec mocks base method.
func (m *MockTransaction) Exec(query string, args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []any{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockTransactionMockRecorder) Exec(query any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockTransaction)(nil).Exec), varargs...)
}

// ExecContext mocks base method.
func (m *MockTransaction) ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecContext", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecContext indicates an expected call of ExecContext.
func (mr *MockTransactionMockRecorder) ExecContext(ctx, query any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecContext", reflect.TypeOf((*MockTransaction)(nil).ExecContext), varargs...)
}

// Prepare mocks base method.
func (m *MockTransaction) Prepare(query string) (*sql.Stmt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prepare", query)
	ret0, _ := ret[0].(*sql.Stmt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Prepare indicates an expected call of Prepare.
func (mr *MockTransactionMockRecorder) Prepare(query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prepare", reflect.TypeOf((*MockTransaction)(nil).Prepare), query)
}

// PrepareContext mocks base method.
func (m *MockTransaction) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareContext", ctx, query)
	ret0, _ := ret[0].(*sql.Stmt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PrepareContext indicates an expected call of PrepareContext.
func (mr *MockTransactionMockRecorder) PrepareContext(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareContext", reflect.TypeOf((*MockTransaction)(nil).PrepareContext), ctx, query)
}

// Query mocks base method.
func (m *MockTransaction) Query(query string, args ...any) (*sql.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []any{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockTransactionMockRecorder) Query(query any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockTransaction)(nil).Query), varargs...)
}

// QueryContext mocks base method.
func (m *MockTransaction) QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryContext", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryContext indicates an expected call of QueryContext.
func (mr *MockTransactionMockRecorder) QueryContext(ctx, query any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryContext", reflect.TypeOf((*MockTransaction)(nil).QueryContext), varargs...)
}

// QueryRow mocks base method.
func (m *MockTransaction) QueryRow(query string, args ...any) *sql.Row {
	m.ctrl.T.Helper()
	varargs := []any{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(*sql.Row)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockTransactionMockRecorder) QueryRow(query any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockTransaction)(nil).QueryRow), varargs...)
}

// QueryRowContext mocks base method.
func (m *MockTransaction) QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRowContext", varargs...)
	ret0, _ := ret[0].(*sql.Row)
	return ret0
}

// QueryRowContext indicates an expected call of QueryRowContext.
func (mr *MockTransactionMockRecorder) QueryRowContext(ctx, query any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRowContext", reflect.TypeOf((*MockTransaction)(nil).QueryRowContext), varargs...)
}

// Rollback mocks base method.
func (m *MockTransaction) Rollback() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback")
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockTransactionMockRecorder) Rollback() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockTransaction)(nil).Rollback))
}
